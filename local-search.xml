<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>windows操作系统学习之进程和线程</title>
    <link href="/2023/07/24/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/07/24/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程资源"><a href="#进程资源" class="headerlink" title="进程资源"></a>进程资源</h3><p><img src="/images/2.png"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">!process <span class="hljs-number">0</span> <span class="hljs-number">0</span> wermger.exe 来显示wermgr进程的属性<br></code></pre></td></tr></table></figure><h3 id="EPROCESS结构"><a href="#EPROCESS结构" class="headerlink" title="EPROCESS结构"></a>EPROCESS结构</h3><p>每个进程都有一个EPROCESS结构</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">!process EPROCESS地址 <span class="hljs-comment">//来显示该进程的关键信息</span><br></code></pre></td></tr></table></figure><h3 id="PEB结构"><a href="#PEB结构" class="headerlink" title="PEB结构"></a>PEB结构</h3><p>PEB(Process Environment Block):进程环境块。是在内核模式建立后映射到用户空间的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">dt_PEB <span class="hljs-regexp">//</span>显示PEB结构的字段及当前值<br></code></pre></td></tr></table></figure><h3 id="快速系统调用"><a href="#快速系统调用" class="headerlink" title="快速系统调用"></a>快速系统调用</h3><p>比系统调用更快的系统调用</p><h3 id="逆向调用"><a href="#逆向调用" class="headerlink" title="逆向调用"></a>逆向调用</h3><p>内核模式的代码主动调用用户模式的代码</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h3><p>NT内核使用ETHREAD来描述线程</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">.thread <span class="hljs-regexp">//</span>显示当前线程的ETHREAD结构地址<br>dt _ETHREAD 线程的ETHREAD结构地址 <span class="hljs-regexp">//</span>显示ETHREAD结构的内容<br>dt _KTHREAD 线程的ETHREAD结构地址 <span class="hljs-regexp">//</span>显示KTHREAD结构的内容<br>!thread 线程的ETHREAD结构地址 <br></code></pre></td></tr></table></figure><p>ETHREAD开头的512字节是一个KTHREAD结构，称为线程控制块（TCB）主要供内核调度线程时使用。</p><p>NT内核为每个CPU定义了一个处理器控制块（Processor Control Block,PRCB)</p><h3 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h3><p>线程环境块（Thread Environment Block)：描述线程的用户空间信息，包括用户态栈，异常处理，错误码，线程局部存储等。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">!teb <span class="hljs-regexp">//</span>显示当前线程的TEB结构位置<br>dt _TEB+地址 <span class="hljs-regexp">//</span>直接观察TEB结构<br></code></pre></td></tr></table></figure><h2 id="wow进程"><a href="#wow进程" class="headerlink" title="wow进程"></a>wow进程</h2><p>为了兼容老的32位应用程序’64位的Windows系统上可以运行32位的应用程序’这样运行在64位内核上的32位进程有—个专门的名字’叫作WOW64（Windows32onWindows64）进程</p><p><img src="/images/3.png"></p><p>32位程序需要使用的32位的Win32API和一些库函数存放在%windir%\SysWOW64目录下，%windir%\System32存放的是64位的系统文件。</p><p><img src="/images/4.png"></p><p>在Wow进程中，每个进程有2个PEB,每个线程有2个TEB,有2个栈。</p><h3 id="windbg调试WoW进程"><a href="#windbg调试WoW进程" class="headerlink" title="windbg调试WoW进程"></a>windbg调试WoW进程</h3><p>具体操作参考书籍，操作时注意要使用64位的windbg，而不是windbg preview。</p><h3 id="注册表重定向"><a href="#注册表重定向" class="headerlink" title="注册表重定向"></a>注册表重定向</h3><p>64位操作系统对WoW进程的注册表访问实施重定向。</p><h3 id="注册表反射"><a href="#注册表反射" class="headerlink" title="注册表反射"></a>注册表反射</h3><p>对于某些COM组件有关的表键，对一个版本做的设置会自动更新到另一边</p><h3 id="文件系统重定向"><a href="#文件系统重定向" class="headerlink" title="文件系统重定向"></a>文件系统重定向</h3><p>在WoW进程中，有2个NTDLL.dll，一个是64位的，另一个是32位的。当32位的WoW进程访问系统文件目录时，会被自动重定向到SysWOW64目录</p><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p><img src="/images/5.png"></p><h2 id="最小进程和Pico进程"><a href="#最小进程和Pico进程" class="headerlink" title="最小进程和Pico进程"></a>最小进程和Pico进程</h2><h3 id="最小进程"><a href="#最小进程" class="headerlink" title="最小进程"></a>最小进程</h3><p>在创建进程时，指定一个特殊的标志，告诉NT内核，只创建进程空间，不要自动向进程空间中添加内容。</p><h3 id="Pico进程"><a href="#Pico进程" class="headerlink" title="Pico进程"></a>Pico进程</h3><p>最小进程的一个子类，通过一组接口和NT内核交互。</p><hr>]]></content>
    
    
    <categories>
      
      <category>软件调试2读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>winafl初步使用</title>
    <link href="/2023/07/15/winafl%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/07/15/winafl%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>最近对windows漏洞感兴趣，学了一下winafl,来记录一下。</p><h2 id="fuzz-7-zip"><a href="#fuzz-7-zip" class="headerlink" title="fuzz 7-zip"></a>fuzz 7-zip</h2><p>感觉没有什么好说的，先用DynamoRIO工具来测试一下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">C</span>:\Users\user\Desktop\DynamoRIO-Windows-<span class="hljs-number">9</span>.<span class="hljs-number">93</span>.<span class="hljs-number">19545</span>\bin32\drrun.exe -c winafl.dll -debug -target_module <span class="hljs-number">7</span>z.exe -target_offset <span class="hljs-number">0</span>x03B9F3 -fuzz_iterations <span class="hljs-number">10</span> -nargs <span class="hljs-number">2</span> -- <span class="hljs-string">&quot;C:\Program Files (x86)\7-Zip\7z.exe&quot;</span> l C:\Users\user\Desktop\fuzz\example.img<br></code></pre></td></tr></table></figure><p>然后用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">afl</span>-fuzz.exe -i C:\Users\user\Desktop\fuzz\<span class="hljs-number">7</span>_zip -o C:\Users\user\Desktop\fuzz\<span class="hljs-number">7</span>_out -t <span class="hljs-number">2000</span> -D C:\Users\user\Desktop\DynamoRIO-Windows-<span class="hljs-number">9</span>.<span class="hljs-number">93</span>.<span class="hljs-number">19545</span>\bin32 -- -coverage_module <span class="hljs-number">7</span>z.exe -coverage_module <span class="hljs-number">7</span>z.dll -target_module <span class="hljs-number">7</span>z.exe -target_offset <span class="hljs-number">0</span>x03B9F3 -nargs <span class="hljs-number">2</span> -- <span class="hljs-string">&quot;C:\Program Files (x86)\7-Zip\7z.exe&quot;</span> e -y @@<br></code></pre></td></tr></table></figure><p>开始fuzz。要注意这条命令需在winafl目录下，并在管理员权限下运行。</p><p><img src="/images/1.png"></p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>这样其实效率很低，可以参考<a href="https://www.freebuf.com/articles/system/216437.html">https://www.freebuf.com/articles/system/216437.html</a> 来直接fuzz对应的函数。</p><p>再去读读afl源码，并做好笔记</p>]]></content>
    
    
    <categories>
      
      <category>模糊测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
