<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FOs操作系统开发之环境搭建</title>
    <link href="/2023/08/03/FOs%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/08/03/FOs%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>毕设写一个操作系统!!!</p><p>毕设写一个操作系统!!!</p><p>毕设写一个操作系统!!!</p><p>重要的事情说三编 XD)</p><p>在差不多一年前，看完《操作系统真相还原》后，就萌生了写一个操作系统的想法。书中启动是用bios启动的，编写就很麻烦，光loader,汇编就要写不少。然后，我打算用UEFI启动，然后，后面的内核实现部分还没想好，先把启动部分写好，再思考内核部分的实现。</p><p>准备把本人写的系统叫做FOs,寓意是fun os，just for fun。没错，就是这样。</p><p><img src="/images/t.png"></p><p>​        My name is Linus Torvalds and I am your god.</p><p>开个玩笑。XD)</p><p>开始环境搭建，下载ubuntu20的iso，vmware安装，换源，挂代理，安装edk2，build，运行helloworld，一顿操作猛如虎，但是，应该是apt 安装的qemu版本太低了，运行uefi固件时一直黑屏，F**k you。</p><p><img src="/images/qemu.png"></p><p>然后，自己去下载，编译qemu也报错。在折腾了2天后。发现了一个已经搭建好的环境。Oops&#x1f602;。</p><p><a href="https://zhuanlan.zhihu.com/p/458785374">https://zhuanlan.zhihu.com/p/458785374</a></p><p>环境就此搭好。</p><p>下一章预告:实现UEFI启动。</p>]]></content>
    
    
    <categories>
      
      <category>FOs操作系统开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FOs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本数据类型的表现形式</title>
    <link href="/2023/07/28/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"/>
    <url>/2023/07/28/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>以下内容只是本人的一些读书小笔记，详细内容请看书籍。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><h3 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h3><p>负数在内存中都是以补码形式存放的</p><h3 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h3><h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><p>浮点数的操作不会用到通用寄存器，而是会使用浮点协处理器的浮点寄存器，专门对浮点数进行运算处理</p><h3 id="基本的浮点数指令"><a href="#基本的浮点数指令" class="headerlink" title="基本的浮点数指令"></a>基本的浮点数指令</h3><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><p>在C++中，以’\0’作为字符串结束标记。每个字符都记录在一张表中，它们各自对应一个唯一编号，系统通过这些编号查找到对应的字符并显示</p><h3 id="字符的编码"><a href="#字符的编码" class="headerlink" title="字符的编码"></a>字符的编码</h3><p>字符的编码格式分为两种：ASCII(占一字节）和Unicode（占2字节）</p><h3 id="字符串的存储方式"><a href="#字符串的存储方式" class="headerlink" title="字符串的存储方式"></a>字符串的存储方式</h3><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><h2 id="地址-指针-引用"><a href="#地址-指针-引用" class="headerlink" title="地址 指针 引用"></a>地址 指针 引用</h2><p>引用类型实际上就是指针类型，只不过用于存放地址的内存空间对使用者而言是隐藏的</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="#define和const的区别"></a>#define和const的区别</h3><p>#define修饰的符号名称是一个真量数值，而const修饰的栈常量，是一个“假”常量。在实际中，使用const定义的栈变量，最终还是一个变量，只是在编译期间对语法进行了检查，发现代码有对const修饰的变量存在直接修改行为则报错。</p><p>被const修饰过的栈变量本质上是可以被修改的。我们可以利用指针获取const修饰过的栈变量地址，强制将const属性修饰去掉，就可以修改对应的数据内容</p>]]></content>
    
    
    <categories>
      
      <category>C++反汇编与逆向分析技术揭秘读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows操作系统学习之架构和系统部件</title>
    <link href="/2023/07/25/%E6%9E%B6%E6%9E%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E9%83%A8%E4%BB%B6/"/>
    <url>/2023/07/25/%E6%9E%B6%E6%9E%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E9%83%A8%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/6.png"></p><h2 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h2><p><img src="/images/7.png"></p><h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><h3 id="常规进程"><a href="#常规进程" class="headerlink" title="常规进程"></a>常规进程</h3><p>用户空间运行着的操作系统的一些进程</p><p><img src="/images/8.png"></p><h2 id="内核和HAL模块"><a href="#内核和HAL模块" class="headerlink" title="内核和HAL模块"></a>内核和HAL模块</h2><h3 id="内核文件"><a href="#内核文件" class="headerlink" title="内核文件"></a>内核文件</h3><p>在多处理器系统的多处理器版本，64位Windows系统中原始文件名为NTKRNLMP.EXE，并·将其复制到system32目录下。</p><p>（最新版的win10好像把文件名改了，我找不到这个文件了）</p><h3 id="HAL文件"><a href="#HAL文件" class="headerlink" title="HAL文件"></a>HAL文件</h3><p>和内核文件一样也有很多个版本</p><h2 id="空闲进程"><a href="#空闲进程" class="headerlink" title="空闲进程"></a>空闲进程</h2><h3 id="空闲进程与系统进程"><a href="#空闲进程与系统进程" class="headerlink" title="空闲进程与系统进程"></a>空闲进程与系统进程</h3><p><img src="/images/9.png"></p><p>空闲进程的个数和系统中启用的处理器的个数是一致的。</p><p>空闲进程是操作系统启动时创建的第一个进程。</p><h2 id="系统进程"><a href="#系统进程" class="headerlink" title="系统进程"></a>系统进程</h2><p>系统启动阶段，进程管理器在创建空闲进程后，便创建系统进程。系统进程是系统创建的第二个进程。</p><h2 id="内核空间的其他模块"><a href="#内核空间的其他模块" class="headerlink" title="内核空间的其他模块"></a>内核空间的其他模块</h2><p><img src="/images/10.png"></p><h2 id="NTDLL-DLL"><a href="#NTDLL-DLL" class="headerlink" title="NTDLL.DLL"></a>NTDLL.DLL</h2><p>NTDLL.DLL存在于每个用户进程的用户空间的固定位置。</p><h3 id="调用系统服务的桩函数"><a href="#调用系统服务的桩函数" class="headerlink" title="调用系统服务的桩函数"></a>调用系统服务的桩函数</h3><p>NTDLL.DLL有数百个名为NtXXX的函数。把这些函数叫作桩(stub)函数</p><h3 id="映象文件加载器"><a href="#映象文件加载器" class="headerlink" title="映象文件加载器"></a>映象文件加载器</h3><p>将程序从磁盘加载到内存中</p><p>在windows系统中，由NTDLL.DLL实现，一般简称为LDR</p><p><img src="/images/11.png"></p><h3 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a>运行时库</h3><p>在NTDLL.DLL里面数量最大的一类函数（runtime library)</p><p>都以Rtl开头。</p><p>提供基础的函数，包括字符串操作，时间，内存分配等</p><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>NTDLL.DD还提供了异常分发，调试支持等功能</p><h2 id="环境子系统"><a href="#环境子系统" class="headerlink" title="环境子系统"></a>环境子系统</h2><p>不同类型的程序运行在不同的环境子系统中</p><h2 id="原生进程"><a href="#原生进程" class="headerlink" title="原生进程"></a>原生进程</h2><p>普通应用程序属于某个环境子系统。</p><p>但原生(native)进程不依赖任何子系统，通过特殊的私有接口与内核交互</p><h3 id="几个重要的原生进程"><a href="#几个重要的原生进程" class="headerlink" title="几个重要的原生进程"></a>几个重要的原生进程</h3><h4 id="SMSS"><a href="#SMSS" class="headerlink" title="SMSS"></a>SMSS</h4><p>会话管理器子系统(Session Manager Sub-System)</p><p>NT系统启动时，内核空间准备就绪后，内核就会创建SMSS</p><p>是NT启动过程中第一个以EXE方式创建的进程</p><h4 id="CSRSS"><a href="#CSRSS" class="headerlink" title="CSRSS"></a>CSRSS</h4><p>客户端&#x2F;服务器子系统(Client-Server Sub-system)</p><p>Windows子系统的服务进程</p>]]></content>
    
    
    <categories>
      
      <category>软件调试2读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows操作系统学习之进程和线程</title>
    <link href="/2023/07/24/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/07/24/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程资源"><a href="#进程资源" class="headerlink" title="进程资源"></a>进程资源</h3><p><img src="/images/2.png"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">!process <span class="hljs-number">0</span> <span class="hljs-number">0</span> wermger.exe 来显示wermgr进程的属性<br></code></pre></td></tr></table></figure><h3 id="EPROCESS结构"><a href="#EPROCESS结构" class="headerlink" title="EPROCESS结构"></a>EPROCESS结构</h3><p>每个进程都有一个EPROCESS结构</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">!process EPROCESS地址 <span class="hljs-comment">//来显示该进程的关键信息</span><br></code></pre></td></tr></table></figure><h3 id="PEB结构"><a href="#PEB结构" class="headerlink" title="PEB结构"></a>PEB结构</h3><p>PEB(Process Environment Block):进程环境块。是在内核模式建立后映射到用户空间的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">dt_PEB <span class="hljs-regexp">//</span>显示PEB结构的字段及当前值<br></code></pre></td></tr></table></figure><h3 id="快速系统调用"><a href="#快速系统调用" class="headerlink" title="快速系统调用"></a>快速系统调用</h3><p>传统的Windows系统调用正是通过自陷指令 int 0x2e 进入内核实现系统调用的</p><p>比系统调用更快的系统调用</p><h3 id="逆向调用"><a href="#逆向调用" class="headerlink" title="逆向调用"></a>逆向调用</h3><p>内核模式的代码主动调用用户模式的代码</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h3><p>NT内核使用ETHREAD来描述线程</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">.thread <span class="hljs-regexp">//</span>显示当前线程的ETHREAD结构地址<br>dt _ETHREAD 线程的ETHREAD结构地址 <span class="hljs-regexp">//</span>显示ETHREAD结构的内容<br>dt _KTHREAD 线程的ETHREAD结构地址 <span class="hljs-regexp">//</span>显示KTHREAD结构的内容<br>!thread 线程的ETHREAD结构地址 <br></code></pre></td></tr></table></figure><p>ETHREAD开头的512字节是一个KTHREAD结构，称为线程控制块（TCB）主要供内核调度线程时使用。</p><p>NT内核为每个CPU定义了一个处理器控制块（Processor Control Block,PRCB)</p><h3 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h3><p>线程环境块（Thread Environment Block)：描述线程的用户空间信息，包括用户态栈，异常处理，错误码，线程局部存储等。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">!teb <span class="hljs-regexp">//</span>显示当前线程的TEB结构位置<br>dt _TEB+地址 <span class="hljs-regexp">//</span>直接观察TEB结构<br></code></pre></td></tr></table></figure><h2 id="wow进程"><a href="#wow进程" class="headerlink" title="wow进程"></a>wow进程</h2><p>为了兼容老的32位应用程序’64位的Windows系统上可以运行32位的应用程序’这样运行在64位内核上的32位进程有—个专门的名字’叫作WOW64（Windows32onWindows64）进程</p><p><img src="/images/3.png"></p><p>32位程序需要使用的32位的Win32API和一些库函数存放在%windir%\SysWOW64目录下，%windir%\System32存放的是64位的系统文件。</p><p><img src="/images/4.png"></p><p>在Wow进程中，每个进程有2个PEB,每个线程有2个TEB,有2个栈。</p><h3 id="windbg调试WoW进程"><a href="#windbg调试WoW进程" class="headerlink" title="windbg调试WoW进程"></a>windbg调试WoW进程</h3><p>具体操作参考书籍，操作时注意要使用64位的windbg，而不是windbg preview。</p><h3 id="注册表重定向"><a href="#注册表重定向" class="headerlink" title="注册表重定向"></a>注册表重定向</h3><p>64位操作系统对WoW进程的注册表访问实施重定向。</p><h3 id="注册表反射"><a href="#注册表反射" class="headerlink" title="注册表反射"></a>注册表反射</h3><p>对于某些COM组件有关的表键，对一个版本做的设置会自动更新到另一边</p><h3 id="文件系统重定向"><a href="#文件系统重定向" class="headerlink" title="文件系统重定向"></a>文件系统重定向</h3><p>在WoW进程中，有2个NTDLL.dll，一个是64位的，另一个是32位的。当32位的WoW进程访问系统文件目录时，会被自动重定向到SysWOW64目录</p><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p><img src="/images/5.png"></p><h2 id="最小进程和Pico进程"><a href="#最小进程和Pico进程" class="headerlink" title="最小进程和Pico进程"></a>最小进程和Pico进程</h2><h3 id="最小进程"><a href="#最小进程" class="headerlink" title="最小进程"></a>最小进程</h3><p>在创建进程时，指定一个特殊的标志，告诉NT内核，只创建进程空间，不要自动向进程空间中添加内容。</p><h3 id="Pico进程"><a href="#Pico进程" class="headerlink" title="Pico进程"></a>Pico进程</h3><p>最小进程的一个子类，通过一组接口和NT内核交互。</p><hr>]]></content>
    
    
    <categories>
      
      <category>软件调试2读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>winafl初步使用</title>
    <link href="/2023/07/15/winafl%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/07/15/winafl%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>最近对windows漏洞感兴趣，学了一下winafl,来记录一下。</p><h2 id="fuzz-7-zip"><a href="#fuzz-7-zip" class="headerlink" title="fuzz 7-zip"></a>fuzz 7-zip</h2><p>感觉没有什么好说的，先用DynamoRIO工具来测试一下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">C</span>:\Users\user\Desktop\DynamoRIO-Windows-<span class="hljs-number">9</span>.<span class="hljs-number">93</span>.<span class="hljs-number">19545</span>\bin32\drrun.exe -c winafl.dll -debug -target_module <span class="hljs-number">7</span>z.exe -target_offset <span class="hljs-number">0</span>x03B9F3 -fuzz_iterations <span class="hljs-number">10</span> -nargs <span class="hljs-number">2</span> -- <span class="hljs-string">&quot;C:\Program Files (x86)\7-Zip\7z.exe&quot;</span> l C:\Users\user\Desktop\fuzz\example.img<br></code></pre></td></tr></table></figure><p>然后用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">afl</span>-fuzz.exe -i C:\Users\user\Desktop\fuzz\<span class="hljs-number">7</span>_zip -o C:\Users\user\Desktop\fuzz\<span class="hljs-number">7</span>_out -t <span class="hljs-number">2000</span> -D C:\Users\user\Desktop\DynamoRIO-Windows-<span class="hljs-number">9</span>.<span class="hljs-number">93</span>.<span class="hljs-number">19545</span>\bin32 -- -coverage_module <span class="hljs-number">7</span>z.exe -coverage_module <span class="hljs-number">7</span>z.dll -target_module <span class="hljs-number">7</span>z.exe -target_offset <span class="hljs-number">0</span>x03B9F3 -nargs <span class="hljs-number">2</span> -- <span class="hljs-string">&quot;C:\Program Files (x86)\7-Zip\7z.exe&quot;</span> e -y @@<br></code></pre></td></tr></table></figure><p>开始fuzz。要注意这条命令需在winafl目录下，并在管理员权限下运行。</p><p><img src="/images/1.png"></p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>这样其实效率很低，可以参考<a href="https://www.freebuf.com/articles/system/216437.html">https://www.freebuf.com/articles/system/216437.html</a> 来直接fuzz对应的函数。</p><p>再去读读afl源码，并做好笔记</p>]]></content>
    
    
    <categories>
      
      <category>模糊测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
